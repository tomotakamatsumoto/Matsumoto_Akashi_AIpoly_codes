/*constants*/#define MAXSEQLEN		3000000				/*maximum length of sequence has to be multiple of 3*/#define MAXSAMPLENUM	1000					/*maximum samplesize*/#define MAXSEQNUM		5000				/*maximum number of sequences even when fluctuating*/#define MINSEQNUM		1000					/*minimum number of sequences even under population fluctuation*/#define MAXGEN			5000000				/*maximum of inirungen, prerungen and reprungen*/#define MAXFIXATIONS	20000000				/*maximum number of fixations permitted in a single initrun or prerun or reprun*//*structure for storing user preferences*/struct userPref_str{	char newLine[10+1];					/*the new line encoding as a string*/	char overWriteOption[30+1];			/*if TRUE then existing files are overwritten. else exist */	char dirSep[10+1];					/*the directory separator to be used*/	char fileOpenMode[10+1];			/*the mode in which the files to be created are to be opened*/	char controlFile[MAXLINECHAR+1];	/*path+name of control file*/	char rootInputFolder[MAXLINECHAR+1];	/*path+name to root input folder*/	char rootOutputFolder[MAXLINECHAR+1];	/*path+name to root output folder*/	long process_choice;	long process_choice_arr_len;	long process_choice_arr[11];		/* from fsim */	char comments[MAXFILENAME+1];	char version[MAXFILENAME+1];	char fsimVersion[MAXFILENAME+1];	char machineName[MAXFILENAME+1];	char outFileName[MAXFILENAME+1];	char outFileExtn[MAXFILENAME+1];		long noMultiHit;	long repNum;	long initRunGen;	long preRunGen;	long repRunGen;    long uswitch; /*matsumoto; generation after that mutation rate switch to "b"*/    long prerunSeqNum;	long initSeqNum;    long SeqNum_b;	long seqLen;	long sampleNum;	double c;    double c_b;    double u_a;    double u_b;    double u01_a;    double u02_a;    double u03_a;    double u10_a;    double u12_a;    double u13_a;    double u20_a;    double u21_a;    double u23_a;    double u30_a;    double u31_a;    double u32_a;    double u01_b;    double u02_b;    double u03_b;    double u10_b;    double u12_b;    double u13_b;    double u20_b;    double u21_b;    double u23_b;    double u30_b;    double u31_b;    double u32_b;        double fitness_p;    double fitness_u;            char codon_change[64][64];    char init_seq_dat[MAXSEQNUM][MAXSEQLEN];    char anc_init_seq_dat[MAXSEQLEN];        long idum_init;        /* end from fsim */        char outputfile[MAXFILENAME+1];    char OutputFolder[MAXFILENAME+1];};/****************************************************************************************/unsigned long checkUserInputs(struct userPref_str *userPrefp);unsigned long readControlFile(struct userPref_str **userPrefp);unsigned long read_codon_table_a(struct userPref_str *userPrefp, char *tokenName, char *tokenValue);unsigned long read_seq_dat_after_burnin(struct userPref_str *userPrefp, char *tokenName, char *tokenValue);unsigned long readControlFile_c(struct userPref_str **userPrefp);void copy_ctl_file(struct userPref_str *userPrefp);void init_ctl_strings(struct userPref_str **userPrefp);/****************************************************************************************//*function to read the control file and check the values entered by the user. Function allocates memory for the userPref structure to be filled. returns 0if successful. Exits with error if notuserPrefp - pointer to pointer to userPrefp structure to be allocated memory forcreated 		08-13-03	Anoop Johnlast Modified	08-22-03	Piyush Goel*/unsigned long readControlFile(struct userPref_str **userPrefp){	unsigned long returnVal;			/*the value to be returned from function 0 if ok*/	char inputString[MAXLINECHAR+1];	/*variable for storing the string input from the user*/	FILE *fp;							/*file pointer to the control file*/ 	const char *defaultInputFolder = "../10.input/";/*default input folder*/	char tokenName[MAXLINECHAR+1];		/*name of token extracted from the input string*/	char tokenValue[MAXLINECHAR+1];		/*value of token extracted*/	int assumeDefaultRootInputFolder = 1;/*if this is 1 then the program will assume that the control file										is in the defaultInputFolder*/	const char *defaultControlFile = "0.ctl";/*name of the default control file*/	const char *controlFileTokenSeparator = "=:";/*the different token separators in the control file*/	long i, len, process_choice_long;	char temp_str[MAXLINECHAR+1], temp_str2[2];		returnVal = 0;	/*allocate memory for the userpref structure and initialize strings to 'X' */	*userPrefp = (struct userPref_str*) memAlloc (1, sizeof(struct userPref_str), "userPref :readControlFile");	init_ctl_strings(userPrefp);	/*Input Folder*/	printf("Control file will be assumed to be in the default folder: %s\n", defaultInputFolder);	if (assumeDefaultRootInputFolder == 0)	{		getUserString("Enter name of input folder(eg. '::10.input:')\nor Hit Return for default: ", inputString, MAXLINECHAR);		if(isBlankString(inputString) != 0)			strcpy((*userPrefp)->controlFile, defaultInputFolder);		else			strcpy((*userPrefp)->controlFile, inputString);		printf("\n");	}	else	{		strcpy((*userPrefp)->controlFile, defaultInputFolder);	}	printf("Default Control File name: %s\n", defaultControlFile);	getUserString("Enter name of control file or Hit Return for default: ", inputString, MAXLINECHAR);	if(isBlankString(inputString) != 0)		strcat((*userPrefp)->controlFile, defaultControlFile);	else		strcat((*userPrefp)->controlFile, inputString);	fp = fileOpen((*userPrefp)->controlFile, "rb");	/*make input string a zero length string*/	inputString[0] = 0;	do	{		/*read a line from the control file*/		getFileLineRemoveComments(fp, inputString, MAXLINECHAR);		removeExtraWhiteSpaces(inputString);		/*process if the string is not blank*/		if(isBlankString(inputString) == 0)		{			getTokenNameAndValue(inputString, tokenName, controlFileTokenSeparator, tokenValue);			#ifdef VERBOSE						printf("token name = \"%s\"\t value = \"%s\"\n", tokenName, tokenValue);			#endif			/*process tokens as we recognize them*/			if(strCmpIgnoreCase(tokenName, "rootInputFolder") == 0)				strcpy((*userPrefp)->rootInputFolder, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "rootOutputFolder") == 0)				strcpy((*userPrefp)->rootOutputFolder, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "dirSep") == 0)				strcpy((*userPrefp)->dirSep, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "fileOpenMode") == 0)				strcpy((*userPrefp)->fileOpenMode, tokenValue);			else if(strCmpIgnoreCase(tokenName, "newLine") == 0)				strcpy((*userPrefp)->newLine, tokenValue);			else if(strCmpIgnoreCase(tokenName, "overWriteOption") == 0)				strcpy((*userPrefp)->overWriteOption, tokenValue);						else if(strCmpIgnoreCase(tokenName, "process_choice") == 0)				process_choice_long = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "comments") == 0)				strcpy((*userPrefp)->comments, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "version") == 0)				strcpy((*userPrefp)->version, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "fsimVersion") == 0)				strcpy((*userPrefp)->fsimVersion, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "machineName") == 0)				strcpy((*userPrefp)->machineName, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "outFileName") == 0)				strcpy((*userPrefp)->outFileName, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "outFileExtn") == 0)				strcpy((*userPrefp)->outFileExtn, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "noMultiHit") == 0)				(*userPrefp)->noMultiHit = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "repNum") == 0)				(*userPrefp)->repNum = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "initRunGen") == 0)				(*userPrefp)->initRunGen = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "preRunGen") == 0)				(*userPrefp)->preRunGen = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "repRunGen") == 0)				(*userPrefp)->repRunGen = StringToLong(tokenValue);            else if(strCmpIgnoreCase(tokenName, "uswitch") == 0)                (*userPrefp)->uswitch = StringToLong(tokenValue);            else if(strCmpIgnoreCase(tokenName, "prerunSeqNum") == 0)                (*userPrefp)->prerunSeqNum = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "initSeqNum") == 0)				(*userPrefp)->initSeqNum = StringToLong(tokenValue);            else if(strCmpIgnoreCase(tokenName, "SeqNum_b") == 0)                (*userPrefp)->SeqNum_b = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "seqLen") == 0)				(*userPrefp)->seqLen = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "sampleNum") == 0)				(*userPrefp)->sampleNum = StringToLong(tokenValue);			else if(strCmpIgnoreCase(tokenName, "c") == 0)				(*userPrefp)->c = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "c_b") == 0)                (*userPrefp)->c_b = StringToDouble(tokenValue);			else if(strCmpIgnoreCase(tokenName, "u_a") == 0)				(*userPrefp)->u_a = StringToDouble(tokenValue);			else if(strCmpIgnoreCase(tokenName, "u_b") == 0)				(*userPrefp)->u_b = StringToDouble(tokenValue);                        else if(strCmpIgnoreCase(tokenName, "u01_a") == 0)                (*userPrefp)->u01_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u02_a") == 0)                (*userPrefp)->u02_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u03_a") == 0)                (*userPrefp)->u03_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u10_a") == 0)                (*userPrefp)->u10_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u12_a") == 0)                (*userPrefp)->u12_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u13_a") == 0)                (*userPrefp)->u13_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u20_a") == 0)                (*userPrefp)->u20_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u21_a") == 0)                (*userPrefp)->u21_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u23_a") == 0)                (*userPrefp)->u23_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u30_a") == 0)                (*userPrefp)->u30_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u31_a") == 0)                (*userPrefp)->u31_a = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u32_a") == 0)                (*userPrefp)->u32_a = StringToDouble(tokenValue);                        else if(strCmpIgnoreCase(tokenName, "u01_b") == 0)                (*userPrefp)->u01_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u02_b") == 0)                (*userPrefp)->u02_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u03_b") == 0)                (*userPrefp)->u03_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u10_b") == 0)                (*userPrefp)->u10_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u12_b") == 0)                (*userPrefp)->u12_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u13_b") == 0)                (*userPrefp)->u13_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u20_b") == 0)                (*userPrefp)->u20_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u21_b") == 0)                (*userPrefp)->u21_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u23_b") == 0)                (*userPrefp)->u23_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u30_b") == 0)                (*userPrefp)->u30_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u31_b") == 0)            (*userPrefp)->u31_b = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "u32_b") == 0)            (*userPrefp)->u32_b = StringToDouble(tokenValue);                        else if(strCmpIgnoreCase(tokenName, "fitness_p") == 0)            (*userPrefp)->fitness_p = StringToDouble(tokenValue);            else if(strCmpIgnoreCase(tokenName, "fitness_u") == 0)            (*userPrefp)->fitness_u = StringToDouble(tokenValue);                        else if(strCmpIgnoreCase(tokenName, "idum_init") == 0)            (*userPrefp)->idum_init = StringToLong(tokenValue);            			else if(strCmpIgnoreCase(tokenName, "outputfile") == 0)				strcpy((*userPrefp)->outputfile, extractStringFromQuotedString(tokenValue));			else if(strCmpIgnoreCase(tokenName, "OutputFolder") == 0)				strcpy((*userPrefp)->OutputFolder, extractStringFromQuotedString(tokenValue));				            read_codon_table_a ((*userPrefp), tokenName, tokenValue);            read_seq_dat_after_burnin ((*userPrefp), tokenName, tokenValue);                        //printf ("aa %s\n", (*userPrefp)->init_seq_dat[1]);			//else			//{			//	printf("Unrecognized token \"%s\" and value \"%s\" read from %s\n", tokenName, tokenValue, (*userPrefp)->controlFile);			//	halt;			//}		}	}    	while(!feof(fp));	/*--- extract process choices (string to int array) --------------------------*///	printf("process choice check\n");//	halt;//	printf("process choice long: %0ld\n", process_choice_long);	sprintf(temp_str, "%ld", process_choice_long);//	printf("process choice str: %s\n", temp);	len = strlen(temp_str);	(*userPrefp)->process_choice_arr_len = len;	if (len > 10)	{		printf("process_choice_str max length is 10.  Please recode userpref.h for max = %0ld for %s", len, temp_str);		halt;	}//	printf("process choice strlen: %0ld", len);//	halt;	(*userPrefp)->process_choice_arr[0] = 3;//	printf("test 1: %0ld\n", (*userPrefp)->process_choice_arr[0]);//	halt;	for (i=0; i<len; i++)	{		temp_str2[0] = temp_str[i];		temp_str2[1] = '\0';		((*userPrefp)->process_choice_arr)[i+1] = atoi(temp_str2);	}//	printf("loop done\n");//	halt;	printf("\tprocess choice: \n");	for (i=1; i<=len; i++)		printf("%10ld:%5ld\n", i, (*userPrefp)->process_choice_arr[i]);//	printf("\nplease hit return to confirm\n");//	halt;	/*---- end extract error codes -------------------------*/	checkUserInputs((*userPrefp));	fclose(fp);	copy_ctl_file((*userPrefp));        printf ("64 * 64 table of mutation type. 3: three preferred sites, 2: two preferred sites, 1: one preferred site, 0: zero preferred site\n");    int tomo, taka;    for (tomo=0;tomo<=63;tomo++) {        for (taka=0;taka<=63;taka++) {            printf ("%c, ", (*userPrefp)->codon_change[tomo][taka]);        }        printf ("\n");    }    /*printf ("check input ancestral sequence\n");    for (tomo=1001;tomo<=1001;tomo++) {        for (taka=0;taka<=99;taka++) {            printf ("%c", (*userPrefp)->init_seq_dat[onon][joj]);        }        printf ("\n");    }*/	return returnVal;}/* 151221 matsumoto: read codon list in input file */unsigned long read_codon_table_a (struct userPref_str *userPrefp, char *tokenName, char *tokenValue){    char codon_number[10];    int tomo, taka;        for (tomo=1;tomo<=1;tomo++) {        for (taka=1;taka<=64;taka++) {            sprintf (codon_number, "C%d_%d_", tomo, taka);            if(strCmpIgnoreCase(tokenName, codon_number) == 0)            strcpy(&(userPrefp)->codon_change[tomo-1][taka-1], extractStringFromQuotedString(tokenValue));        }    }    for (tomo=2;tomo<=64;tomo++) {        for (taka=1;taka<=64;taka++) {            (userPrefp)->codon_change[tomo-1][taka-1] = (userPrefp)->codon_change[0][taka-1];        }    }    return 0;}/* 151221 matsumoto: read sequences of initial population in input file */unsigned long read_seq_dat_after_burnin (struct userPref_str *userPrefp, char *tokenName, char *tokenValue){    char seq_number[10];    int tomo;        for (tomo=1;tomo<=1000;tomo++) {        sprintf (seq_number, "seq_%d_", tomo);        if(strCmpIgnoreCase(tokenName, seq_number) == 0)     strcpy((userPrefp)->init_seq_dat[tomo], extractStringFromQuotedString(tokenValue));    }        if(strCmpIgnoreCase(tokenName, "ancestor_") == 0)     strcpy((userPrefp)->anc_init_seq_dat, extractStringFromQuotedString(tokenValue));        return 0;}/****************************************************************************************/void init_ctl_strings(struct userPref_str **userPrefp)/* intialize userpref strings to "X" to avoid read functions for undefined variables	this way, not all ctl files have to have all string */{	printf("init_ctl_strings\n");		(*userPrefp)->comments[0] = 'X';	(*userPrefp)->version[0] = 'X';	(*userPrefp)->fsimVersion[0] = 'X';	(*userPrefp)->machineName[0] = 'X';	(*userPrefp)->outFileName[0] = 'X';	(*userPrefp)->outFileExtn[0] = 'X';		return;}/****************************************************************************************//*function to check user inputs and display the values read from the control filefunction will create directories if neededuserPrefp - pointer to the userPref structure to be checkedcreated 		08-13-03	Anoop Johnlast Modified	11-04-03	Piyush Goel */unsigned long checkUserInputs(struct userPref_str *userPrefp){	char * temp_str;	/*check if folder names end with directory separators and if so then remove directory separator*/	fixFolderName(userPrefp->rootInputFolder, userPrefp->dirSep);	fixFolderName(userPrefp->rootOutputFolder, userPrefp->dirSep);	/*output the values to the screen*/	printf("----------------------------------------\n");	printf("rootInputFolder    : %s\n", userPrefp->rootInputFolder);	printf("rootOutputFolder   : %s\n", userPrefp->rootOutputFolder);	printf("dirSep             : %s\n", userPrefp->dirSep);	printf("fileOpenMode       : %s\n", userPrefp->fileOpenMode);	printf("newLine            : %s\n", userPrefp->newLine);	printf("overWriteOption    : %s\n", userPrefp->overWriteOption);	printf("----------------------------------------\n");// 	printf("gene_info_file     	: %s\n", userPrefp->gene_info_file);// 	printf("isoform_info  		: %s\n", userPrefp->isoform_info);// 	printf("get_seqs     		: %0ld\n", userPrefp->get_seqs);// 	printf("get_GO     			: %0ld\n", userPrefp->get_GO);// 	printf("read_geneinfo36     : %0ld\n", userPrefp->read_geneinfo36);// 	printf("FB_not_present		: %s\n", userPrefp->FB_not_present);// 	printf("----------------------------------------\n");	halt;	/*check fileOpenMode and newLine encoding*/	if(strCmpIgnoreCase(userPrefp->fileOpenMode, "text") == 0)		strcpy(userPrefp->fileOpenMode, "w");	else if(strCmpIgnoreCase(userPrefp->fileOpenMode, "binary") == 0)		strcpy(userPrefp->fileOpenMode, "wb");	else		errorOut(("Invalid fileOpenMode parameter - %s, Valid are BINARY and TEXT", userPrefp->fileOpenMode));	if(strCmpIgnoreCase(userPrefp->newLine, "CR") == 0)		strcpy(userPrefp->newLine, "\r");	else if(strCmpIgnoreCase(userPrefp->newLine, "LF") == 0)		strcpy(userPrefp->newLine, "\n");	else if(strCmpIgnoreCase(userPrefp->newLine, "CRLF") == 0)		strcpy(userPrefp->newLine, "\r\n");	else		errorOut(("Invalid newLine parameter - %s, Valid are CR, LF and CRLF", userPrefp->newLine));	/* create output folder */	temp_str = CreateFolder(userPrefp->rootOutputFolder, 0);	sprintf(userPrefp->rootOutputFolder, "%s", temp_str);	free(temp_str);	return 0;}/*--------------------------------------------------------------------------------*/void copy_ctl_file(struct userPref_str *userPrefp)/* makes a copy of the ctl file in the output folder - date stamp is added */{		char outputfile[500];		sprintf(outputfile, "%s%s%s", userPrefp->rootOutputFolder, userPrefp->dirSep, "0.ctl_out");	copy_file_w_time(userPrefp->controlFile, outputfile);		return;}/****************************************************************************************/